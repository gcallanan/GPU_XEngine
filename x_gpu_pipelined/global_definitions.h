#include <cstdint>

//Global Defines
#define NUM_ANTENNAS 64
#define NUM_CHANNELS_PER_XENGINE 16 
#define NUM_POLLS 2
#define NUM_TIME_SAMPLES 256
#define QUADRANT_SIZE ((NUM_ANTENNAS/2+1)*(NUM_ANTENNAS/4))
#define NUM_BASELINES (QUADRANT_SIZE*4)

//Global Structs

/**
 * Struct storing samples as formatted bythe F-Engines
 */
typedef struct DualPollComplexStruct_in {
  int8_t realPol0;/**< Pol 0 Real Memeber. */
  int8_t imagPol0;/**< Pol 0 Imaginary Memeber. */
  int8_t realPol1;/**< Pol 1 Real Memeber. */
  int8_t imagPol1;/**< Pol 1 Imaginary Memeber. */
} DualPollComplex_in;

/**
 * Strut contatining baseline products for a pair of antennas. For each antenna pair, two of these structs are required, one for the imaginary component and the other for the real component
 */
#ifndef DP4A
typedef struct BaselineProductsStruct_out {
  float product0;/**< <Antenna0, Antenna0> product. int32*/
  float product1;/**< <Antenna0, Antenna1> product. */
  float product2;/**< <Antenna1, Antenna0> product. */
  float product3;/**< <Antenna1, Antenna1> product. */
} BaselineProducts_out;
#else
typedef struct BaselineProductsStruct_out {
  int32_t product0;/**< <Antenna0, Antenna0> product. */
  int32_t product1;/**< <Antenna0, Antenna1> product. */
  int32_t product2;/**< <Antenna1, Antenna0> product. */
  int32_t product3;/**< <Antenna1, Antenna1> product. */
} BaselineProducts_out;
#endif

/**
 * @brief: Struct containting the data that will be fed into xGPU.
 * 
 * Struct containting the data that will be fed into xGPU.
 * The samples are ordered from [time][channel][station][polarization][complexity](ordered from slowest to fastest changing values) when not using DP4A instructions. 
 * 
 * The ordering is different if DP4A is required, the general ordering remains the same but the timestamps are interleaved . See function (TODO: Insert function here) for more information
 */
typedef struct XGpuPacketInStruct{
    uint64_t timestamp_u64;/**< Timestamp. */
    uint64_t fEnginesPresent_u64;/**< The bits in this field from 0 to NUM_ANTENNAS will be set to 1 if the corresponding F-Engine packet has been recieved or 0 otherwise.. */
    uint64_t frequencyBase_u64;/**< Base Frequency of the samples packet. Frequeny in packet run from frequencyBase_u64 to frequencyBase_u64+NUM_CHANNELS_PER_XENGINE */
    uint8_t numFenginePacketsProcessed;/**< Number of F-Engine packets recieved, equal to NUM_ANTENNAS if all packets are received, missing antennas should have their data zeroed*/
    DualPollComplex_in * samples_s;/**< Pointer to the F-Engine samples. The samples_s array should contain NUM_CHANNELS_PER_XENGINE*NUM_ANTENNAS*NUM_TIME_SAMPLES DualPollComplex_in samples */
} XGpuPacketIn;

/**
 * @brief: Struct containting the data that is generated by xGPU.
 * 
 * Struct containting the data that is generated by xGPU. The data is arranged as [complexity][channel][station][station](ordered from slowest to fastest changing values).
 * The function getBaselineOffset shows the ordering of the [station][station] section. This ordering is complicated as the baselines are split into quadrants based on whether station1/station2 are odd or even 
 */
typedef struct XGpuPacketOutStruct{
    uint64_t timestamp_u64;/**< Timestamp. */
    uint64_t frequencyBase_u64;/**< Base Frequency of the samples packet. Frequeny in packet run from frequencyBase_u64 to frequencyBase_u64+NUM_CHANNELS_PER_XENGINE */
    BaselineProductsStruct_out * baselines;/**< Pointer to xGpu baselines out. The real and imaginary components are split.*/
} XGpuPacketOut;

class StreamObject{
    public:
        StreamObject(uint64_t timestamp_u64,bool eos,uint64_t frequency): timestamp_u64(timestamp_u64),eos(eos),frequency(frequency){

        }
        StreamObject(bool eos): eos(eos){

        }
        uint64_t getTimestamp(){
          return timestamp_u64;
        }
        uint64_t getFrequency(){
          return frequency;
        }
        bool isEOS(){
          return eos;
        }
    protected:
        uint64_t timestamp_u64;
        bool eos;
        uint64_t frequency;
};

class Spead2RxPacket: public StreamObject
{
    public:
        Spead2RxPacket(uint64_t timestamp_u64,bool eos,uint64_t frequency,uint64_t fEngineId,uint8_t *payloadPtr_p, spead2::recv::heap &fheap): StreamObject(timestamp_u64,eos,frequency),fEngineId(fEngineId),fheap(fheap){

        }
        uint64_t getFEngineId(){
          return fEngineId;
        }
        uint8_t * getPayLoadPointer(){
          return payloadPtr_p;
        }
    protected:
        uint64_t fEngineId;
        uint8_t * payloadPtr_p;
        const spead2::recv::heap &fheap;

};